#!KAMAILIO

# Kamailio SIP Server Configuration for Olib AI
# Version 6.0.1 compatible configuration
# This configuration handles SIP signaling for voice calls and SMS with WebSocket bridge to AI platform

####### Global Parameters #########

debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
fork=yes
children=4
tcp_children=4
disable_tcp=no
auto_aliases=no

# Server identification
server_header="Server: Olib-AI-SIP/1.0"
user_agent_header="User-Agent: Olib-AI-SIP/1.0"

# Network configuration
alias="sip.olib.ai"
alias="localhost"
port=5060
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# Memory and performance settings - removed invalid syntax
# shm_mem and pkg_mem must be set via command line (-m and -M flags)
# or use proper parameter syntax if supported

####### Modules Section ########

# Set module path
mpath="/usr/lib/kamailio/modules/"

# Load core modules
loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"

# RTP Proxy for media streaming to AI platform
loadmodule "rtpproxy.so"

# NAT and WebSocket
loadmodule "nathelper.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"

# Authentication and database
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "db_postgres.so"

# Additional modules
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "dispatcher.so"
loadmodule "dialog.so"
# Remove presence modules for now to avoid MySQL dependency issues
# loadmodule "presence.so" 
# loadmodule "presence_xml.so"
loadmodule "jansson.so"
loadmodule "rtimer.so"
loadmodule "sqlops.so"
loadmodule "cfgutils.so"
loadmodule "uac.so"
loadmodule "permissions.so"
loadmodule "acc.so"

####### Module Parameters #######

# Database connection
modparam("db_postgres", "con_param", "connect_timeout=5")
modparam("auth_db|usrloc|dialog|dispatcher|permissions|acc", "db_url", "postgres://kamailio:kamailiopw@postgres/kamailio")

# User location
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 0)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "nat_bflag", 7)

# Registrar module parameters
modparam("registrar", "received_avp", "$avp(received_nh)")

# Authentication
modparam("auth_db", "calculate_ha1", 0)  # HA1 is pre-calculated in database
modparam("auth_db", "password_column", "ha1")  # Use HA1 hash column
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "domain")

# Custom RTP Bridge configuration for AI platform integration
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:12221")
modparam("rtpproxy", "rtpproxy_tout", 5)
modparam("rtpproxy", "rtpproxy_retr", 3)

# HTTP Client for API integration (if available)
# Note: http_client module may not be available in all Kamailio packages
# loadmodule "http_client.so"
# modparam("http_client", "httpcon", "api=>http://127.0.0.1:8000")
# modparam("http_client", "connection_timeout", 5)

# NAT Helper
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@olib.ai")
modparam("nathelper", "received_avp", "$avp(received_nh)")

# WebSocket
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_interval", 5)

# Dialog management (6.0.1 compatible)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "default_timeout", 43200)
modparam("dialog", "db_mode", 1)
modparam("dialog", "dlg_match_mode", 0)

# Transaction module
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "wt_timer", 5000)
modparam("tm", "retr_timer1", 500)
modparam("tm", "retr_timer2", 4000)

# Rate limiting with pike
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# Hash tables for state management
modparam("htable", "htable", "calls=>size=12;autoexpire=7200")
modparam("htable", "htable", "blocked=>size=8;autoexpire=86400")
modparam("htable", "htable", "websocket=>size=8;autoexpire=3600")
modparam("htable", "htable", "registrations=>size=10;autoexpire=3600")

# Dispatcher for SIP trunks
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "force_dst", 1)
modparam("dispatcher", "use_default", 0)
modparam("dispatcher", "xavp_dst", "_dsdst_")
modparam("dispatcher", "xavp_ctx", "_dsctx_")

# UAC for registration and outbound calls (commented out - may not be needed initially)
# modparam("uac", "reg_db_url", "postgres://kamailio:kamailiopw@postgres/kamailio")
# modparam("uac", "reg_timer_interval", 60)
# modparam("uac", "reg_retry_interval", 300)

# Permissions for IP-based authentication  
modparam("permissions", "db_url", "postgres://kamailio:kamailiopw@postgres/kamailio")
modparam("permissions", "trusted_table", "trusted")

# Accounting
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "db_flag", 1)
modparam("acc", "db_missed_flag", 2)

####### Routing Logic ########

# Main SIP request routing logic
request_route {
    # Per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # Handle retransmissions
    if (!is_method("ACK")) {
        if (t_lookup_request()) {
            exit;
        }
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    ### only initial requests (no To tag)

    # Handle CANCEL and re-transmissions
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle REGISTER
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Authentication
    route(AUTH);

    # Handle INVITE requests
    if (is_method("INVITE")) {
        route(INVITE);
        exit;
    }

    # Handle MESSAGE requests (SMS)
    if (is_method("MESSAGE")) {
        route(MESSAGE);
        exit;
    }

    # Handle other methods
    route(OTHER_METHODS);
}

# Per request initial checks
route[REQINIT] {
    # flood detection from same IP and traffic ban for a while
    if (!pike_check_req()) {
        xlog("L_ALERT", "PIKE blocking $rm from $si\n");
        sl_send_reply("503", "Service Unavailable");
        exit;
    }

    # Sanity checks
    if (!sanity_check("1511", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        sl_send_reply("400", "Bad Request");
        exit;
    }

    # Max forwards check
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Check for blocked numbers
    if (is_method("INVITE") && $sht(blocked=>$fU) != $null) {
        sl_send_reply("403", "Forbidden - Number Blocked");
        exit;
    }

    # Handle OPTIONS - keep alive
    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "OK");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # Sequential request within a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(1); # do accounting
            setflag(3); # ... even if the transaction fails
            route(NATMANAGE);
        } else if (is_method("ACK")) {
            # ACK is forwarded stateless
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            # No loose-route, but stateful ACK
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction -> ignore and discard
            exit;
        }
    }
    sl_send_reply("404", "Not here");
    exit;
}

# Authentication route
route[AUTH] {
    # No authentication for trusted sources (SIP trunks)
    if (allow_source_address()) {
        return;
    }

    # Require authentication for requests from local domain or REGISTER
    if (is_method("REGISTER") || from_uri==myself) {
        # Authenticate using database
        if (!auth_check("$td", "subscriber", "1")) {
            # Authentication failed or no credentials provided
            xlog("L_WARN", "Auth failed for user from $si (method: $rm)\n");
            
            # Send authentication challenge
            auth_challenge("$td", "1");
            exit;
        }

        # Authentication successful
        xlog("L_INFO", "Auth successful for $au from $si\n");
        
        # Update user info via API if available
        if (defined $au && $au != "") {
            route(UPDATE_USER_INFO);
        }
        
        # User authenticated - remove auth header
        consume_credentials();
    }
}

# API authentication check route  
route[AUTH_API_CHECK] {
    # Log authentication attempt for monitoring
    xlog("L_INFO", "Additional auth check for user $au from $si\n");
    
    # For now, rely on database authentication only
    # HTTP integration can be added later when http_client module is available
    # The database auth_check() already validates against subscriber table
}

# Update user info route
route[UPDATE_USER_INFO] {
    # Log successful authentication for monitoring
    if (is_method("REGISTER")) {
        xlog("L_INFO", "User $au registered successfully from $si\n");
        
        # Store registration info in hash table for tracking
        $sht(registrations=>$au) = $si + ":" + $Ts;
    }
}

# REGISTRAR route
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    if (isflagset(5) || (proto==WS || proto==WSS)) {
        setbflag(6);
    }

    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# INVITE handling
route[INVITE] {
    setflag(1); # do accounting

    # Create dialog for call tracking
    dlg_manage();

    # Store call information
    $sht(calls=>$ci) = $fU + ":" + $tU + ":" + $Ts;

    # Check if caller is registered (local user)
    if (registered("location")) {
        # This is an outbound call from registered user
        route(OUTBOUND);
        exit;
    } else {
        # This is an inbound call from external source
        route(INBOUND);
        exit;
    }
}

# Inbound call handling
route[INBOUND] {
    # Check if call is from trusted trunk
    if (!allow_source_address()) {
        xlog("L_WARN", "Untrusted inbound call from $si\n");
        sl_send_reply("403", "Forbidden");
        exit;
    }

    xlog("L_INFO", "Inbound call: $ci from $fU to $tU (source: $si)\n");

    # Record route for proper dialog handling
    record_route();

    # Handle NAT
    route(NATMANAGE);

    # Send 100 Trying
    sl_send_reply("100", "Trying");

    # Notify WebSocket bridge about incoming call
    $var(call_payload) = '{"type":"invite","call_id":"' + $ci + '","from":"' + $fU + '","to":"' + $tU + '","source_ip":"' + $si + '"}';
    
    # Log call notification (HTTP async not available in Alpine)
    xlog("L_INFO", "Would notify AI platform about call: $ci from $fU to $tU\\n");
    
    # Forward to WebSocket AI platform 
    $ru = "sip:" + $tU + "@127.0.0.1:8080;transport=ws";
    
    # Set failure route for fallback
    t_on_failure("INBOUND_FAILURE");
    
    # Store WebSocket connection info
    $sht(websocket=>$ci) = "inbound:" + $si + ":" + $fU;

    route(RELAY);
}

# Outbound call handling
route[OUTBOUND] {
    xlog("L_INFO", "Outbound call: $ci from $fU to $tU\n");

    # Record route
    record_route();

    # Handle NAT
    route(NATMANAGE);

    # Select dispatcher group for outbound routing
    if (!ds_select_dst("1", "4")) {
        sl_send_reply("503", "Service Unavailable - No Trunks");
        exit;
    }

    # Set failure route for trunk failover
    t_on_failure("TRUNK_FAILURE");

    route(RELAY);
}

# MESSAGE handling - SMS
route[MESSAGE] {
    # Check content type
    if ($ct != "text/plain") {
        sl_send_reply("415", "Unsupported Media Type");
        exit;
    }

    xlog("L_INFO", "SMS received: from $fU to $tU body: $rb\n");

    # Forward SMS to WebSocket bridge for AI processing
    $var(sms_payload) = '{"type":"sms","from":"' + $fU + '","to":"' + $tU + '","body":"' + $rb + '","call_id":"' + $ci + '"}';
    
    # Log SMS forwarding (HTTP async not available in Alpine)
    xlog("L_INFO", "Would forward SMS to AI platform: $ci body: $rb\\n");
    
    # Send success reply for now
    sl_send_reply("200", "Message Accepted");
}

# Handle other methods
route[OTHER_METHODS] {
    if (is_method("SUBSCRIBE|NOTIFY")) {
        # Presence and messaging
        sl_send_reply("200", "OK");
        exit;
    }
    sl_send_reply("405", "Method Not Allowed");
}

# URI update for dialog requests
route[DLGURI] {
    if (!isdsturiset()) {
        handle_ruri_alias();
    }
}

# NAT detection and management
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if (is_first_hop()) {
                fix_nated_contact();
            }
        }
        setflag(5);
    }
}

# NAT management for media
route[NATMANAGE] {
    if (is_request()) {
        if (has_totag()) {
            if (check_route_param("nat=yes")) {
                setbflag(6);
            }
        }
    }
    if (!(isflagset(5) || isbflagset(6))) return;

    if (is_request()) {
        if (!has_totag()) {
            add_rr_param(";nat=yes");
        }
    }
    if (is_reply()) {
        if (isbflagset(6)) {
            fix_nated_contact();
        }
    }

    # RTP Proxy management
    route(RTPPROXY);
}

# RTP Proxy handling for AI platform media streaming
route[RTPPROXY] {
    if (is_method("INVITE|UPDATE")) {
        if (has_body("application/sdp")) {
            if (rtpproxy_offer("co")) {
                t_on_reply("MANAGE_REPLY");
            }
        }
    } else if (is_method("ACK") && has_body("application/sdp")) {
        rtpproxy_answer("co");
    } else if (is_method("BYE|CANCEL")) {
        rtpproxy_destroy();
    }
}

# Relay route
route[RELAY] {
    # Enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if (!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Branch route
branch_route[MANAGE_BRANCH] {
    xlog("L_DBG", "new branch to $ru\n");
    route(NATMANAGE);
}

# Reply route
onreply_route[MANAGE_REPLY] {
    xlog("L_DBG", "incoming reply\n");
    
    if (status =~ "1[0-9][0-9]") {
        route(NATMANAGE);
        exit;
    }

    if (status =~ "2[0-9][0-9]") {
        route(NATMANAGE);
        if (has_body("application/sdp")) {
            rtpproxy_answer("co");
        }
    }

    if (status =~ "18[0-3]") {
        if (is_method("INVITE")) {
            # 18x for INVITE
            route(NATMANAGE);
        }
    }
}

# Failure route
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }

    # Handle call forwarding or trunk failover here
    if (t_check_status("486|408")) {
        # Busy or timeout
        exit;
    }
}

# Inbound call failure route
failure_route[INBOUND_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }

    xlog("L_INFO", "Inbound call failed: $ci - WebSocket unavailable\n");
    
    # Clean up WebSocket info
    $sht(websocket=>$ci) = $null;
    
    # Send appropriate response
    if (t_check_status("408")) {
        t_reply("503", "AI Platform Unavailable");
    }
}

# Trunk failure route for outbound calls
failure_route[TRUNK_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }

    # Try next trunk in dispatcher group
    if (t_check_status("408|503|404|486|600")) {
        if (ds_next_dst()) {
            xlog("L_INFO", "Trying next trunk for call $ci\n");
            t_relay();
            exit;
        }
    }

    # No more trunks available
    xlog("L_ERR", "All trunks failed for call $ci\n");
}

# HTTP event route for WebSocket and API integration
event_route[xhttp:request] {
    # Set CORS headers
    append_to_reply("Access-Control-Allow-Origin: *\r\n");
    append_to_reply("Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n");
    append_to_reply("Access-Control-Allow-Headers: Content-Type\r\n");

    # Handle OPTIONS requests
    if ($rm == "OPTIONS") {
        xhttp_reply("200", "OK", "", "");
        exit;
    }

    # Handle WebSocket upgrade for SIP integration
    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "upgrade") {
        xlog("L_INFO", "WebSocket request from $si:$sp\n");
        
        # Check if it's for SIP over WebSocket
        if ($hu =~ "^/ws") {
            if (ws_handle_handshake()) {
                xlog("L_INFO", "WebSocket handshake successful\n");
                exit;
            }
        }
        
        xhttp_reply("404", "Not Found", "", "");
        exit;
    }

    # Handle HTTP API requests - forward to API server
    if ($hu =~ "^/api/") {
        xlog("L_INFO", "API request: $rm $hu from $si\n");
        # This would be handled by the API server on port 8000
        xhttp_reply("301", "Moved Permanently", "Location: http://localhost:8000$hu\r\n", "");
        exit;
    }

    # Default response
    xlog("L_INFO", "HTTP request: $rm $hu from $si\n");
    xhttp_reply("404", "Not Found", "", "");
}

# HTTP async reply routes disabled (HTTP async not available in Alpine)
# event_route[http_async_reply] {
#     if ($http_req(method) == "HTTP_CALL_REPLY") {
#         if ($http_rs == 200) {
#             xlog("L_INFO", "AI platform accepted call notification: $ci\n");
#         } else {
#             xlog("L_WARN", "AI platform rejected call notification: $ci (status: $http_rs)\n");
#         }
#     } else if ($http_req(method) == "HTTP_SMS_REPLY") {
#         if ($http_rs == 200) {
#             xlog("L_INFO", "AI platform processed SMS: $ci\n");
#             sl_send_reply("200", "Message Accepted");
#         } else {
#             xlog("L_WARN", "AI platform rejected SMS: $ci (status: $http_rs)\n");
#             sl_send_reply("503", "SMS Processing Failed");
#         }
#     }
# }