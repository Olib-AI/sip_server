#!KAMAILIO

# Kamailio SIP Server Configuration for Olib AI
# This configuration handles SIP signaling for voice calls and SMS

####### Global Parameters #########

debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
fork=yes
children=4
tcp_children=4
disable_tcp=no
auto_aliases=no
alias="sip.olib.ai"
alias="localhost"

# Port configuration
port=5060

# RTP proxy integration (disabled for now)
# rtpengine_sock="udp:127.0.0.1:2223"

####### Modules Section ########

# Set module path
mpath="/usr/lib/kamailio/modules/"

# Load core modules
loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
# loadmodule "rtpengine.so"  # Disabled for now
loadmodule "nathelper.so"
loadmodule "websocket.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "db_postgres.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "dispatcher.so"
loadmodule "dialog.so"
loadmodule "presence.so"
loadmodule "presence_xml.so"
# loadmodule "http_async_client.so"  # Not available in this Kamailio version
loadmodule "jansson.so"
loadmodule "rtimer.so"
loadmodule "sqlops.so"
loadmodule "cfgutils.so"
loadmodule "uac.so"
loadmodule "permissions.so"

# Module parameters

# Database connection
modparam("db_postgres", "con_param", "connect_timeout=5")
modparam("auth_db|usrloc|dialog", "db_url", "postgres://kamailio:kamailiopw@postgres/kamailio")

# User location
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 0)

# Authentication
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")

# RTP Engine (disabled)
# modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

# WebSocket
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_interval", 5)

# NAT Helper
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@olib.ai")

# Dialog
modparam("dialog", "enable_stats", 1)
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "db_mode", 1)

# HTTP Client for webhook notifications
modparam("http_async_client", "workers", 4)
modparam("http_async_client", "connection_timeout", 2000)

# Rate limiting
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# Hash table for call state
modparam("htable", "htable", "calls=>size=8;autoexpire=3600")
modparam("htable", "htable", "blocked=>size=4;autoexpire=86400")

# Dispatcher for SIP trunks
modparam("dispatcher", "db_url", "postgres://kamailio:kamailiopw@localhost/kamailio")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "force_dst", 1)
modparam("dispatcher", "use_default", 0)

# UAC for registration and outbound calls
modparam("uac", "reg_db_url", "postgres://kamailio:kamailiopw@localhost/kamailio")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 300)

# Permissions for IP-based authentication  
modparam("permissions", "db_url", "postgres://kamailio:kamailiopw@localhost/kamailio")
modparam("permissions", "trusted_table", "trusted")

####### Routing Logic ########

# Main SIP request routing logic
request_route {
    # Initial checks
    if (!sanity_check()) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Handle OPTIONS for keep-alive
    if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }

    # Rate limiting
    if (!pike_check_req()) {
        xlog("L_ALERT", "Rate limit exceeded from $si\n");
        sl_send_reply("503", "Service Unavailable");
        exit;
    }

    # Check if number is blocked
    if (is_method("INVITE") && $sht(blocked=>$fU) != $null) {
        sl_send_reply("403", "Forbidden - Number Blocked");
        exit;
    }

    # Handle REGISTER
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Handle INVITE
    if (is_method("INVITE")) {
        route(INVITE);
        exit;
    }

    # Handle MESSAGE (SMS)
    if (is_method("MESSAGE")) {
        route(MESSAGE);
        exit;
    }

    # Handle CANCEL
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # Handle ACK
    if (is_method("ACK")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # Handle BYE
    if (is_method("BYE")) {
        route(BYE);
        exit;
    }

    # Default action
    sl_send_reply("405", "Method Not Allowed");
}

# Registration handling
route[REGISTRAR] {
    if (!www_authorize("$td", "subscriber")) {
        www_challenge("$td", "0");
        exit;
    }

    if (!save("location")) {
        sl_reply_error();
        exit;
    }

    # Notify API about registration
    $var(webhook_url) = "http://localhost:8000/webhooks/registration";
    $var(data) = "{\"user\":\"" + $fU + "\",\"domain\":\"" + $fd + "\",\"contact\":\"" + $ct + "\"}";
    http_async_query($var(webhook_url), $var(data), "WEBHOOK_RESPONSE");
}

# INVITE handling - incoming and outgoing calls
route[INVITE] {
    # Create dialog
    dlg_manage();
    
    # NAT detection
    route(NATDETECT);
    
    # Record routing
    record_route();
    
    # Store call info
    $sht(calls=>$ci) = $fU + ":" + $tU + ":" + $Ts;
    
    # Check if this is an outbound call
    if (is_from_local()) {
        route(OUTBOUND);
        exit;
    }
    
    # Handle inbound call
    route(INBOUND);
}

# Inbound call handling
route[INBOUND] {
    # Check if call is from trusted trunk
    if (!allow_source_address()) {
        xlog("L_WARN", "Untrusted source: $si\n");
        sl_send_reply("403", "Forbidden");
        exit;
    }
    
    # Notify API about incoming call
    $var(webhook_url) = "http://localhost:8000/webhooks/call/incoming";
    $var(data) = "{\"call_id\":\"" + $ci + "\",\"from\":\"" + $fU + "\",\"to\":\"" + $tU + "\",\"source_ip\":\"" + $si + "\"}";
    http_async_query($var(webhook_url), $var(data), "WEBHOOK_RESPONSE");
    
    # Handle RTP
    route(RTPENGINE);
    
    # Send 100 Trying
    sl_send_reply("100", "Trying");
    
    # Forward to WebSocket handler
    t_relay("ws:127.0.0.1:8080");
}

# Outbound call handling
route[OUTBOUND] {
    # Notify API about outbound call for routing
    $var(webhook_url) = "http://localhost:8000/webhooks/call/outbound";
    $var(data) = "{\"call_id\":\"" + $ci + "\",\"from\":\"" + $fU + "\",\"to\":\"" + $tU + "\"}";
    http_async_query($var(webhook_url), $var(data), "OUTBOUND_ROUTING");
    
    # Handle RTP
    route(RTPENGINE);
    
    # Use dispatcher to route to trunk
    if (!ds_select_dst("1", "4")) {
        sl_send_reply("503", "Service Unavailable");
        exit;
    }
    
    # Set failure route for failover
    t_on_failure("TRUNK_FAILURE");
    
    # Forward to selected trunk
    t_relay();
}

# BYE handling - call termination
route[BYE] {
    # Remove call info
    $sht(calls=>$ci) = $null;
    
    # Notify API about call end
    $var(webhook_url) = "http://localhost:8000/webhooks/call/ended";
    $var(data) = "{\"call_id\":\"" + $ci + "\"}";
    http_async_query($var(webhook_url), $var(data), "WEBHOOK_RESPONSE");
    
    # Relay BYE
    t_relay();
}

# MESSAGE handling - SMS
route[MESSAGE] {
    # Check content type
    if ($ct != "text/plain") {
        sl_send_reply("415", "Unsupported Media Type");
        exit;
    }
    
    # Notify API about SMS
    $var(webhook_url) = "http://localhost:8000/webhooks/sms/incoming";
    $var(data) = "{\"from\":\"" + $fU + "\",\"to\":\"" + $tU + "\",\"body\":\"" + $rb + "\"}";
    http_async_query($var(webhook_url), $var(data), "WEBHOOK_RESPONSE");
    
    # Send 200 OK
    sl_send_reply("200", "OK");
}

# NAT detection
route[NATDETECT] {
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            fix_nated_contact();
        }
        setflag(5);
    }
}

# RTP Engine handling
route[RTPENGINE] {
    if (is_method("INVITE")) {
        if (has_body("application/sdp")) {
            # rtpengine_offer("trust-address replace-origin replace-session-connection ICE=remove");
        }
    } else if (is_method("ACK")) {
        if (has_body("application/sdp")) {
            # rtpengine_answer("trust-address replace-origin replace-session-connection ICE=remove");
        }
    }
}

# Webhook response handler
route[WEBHOOK_RESPONSE] {
    if ($http_ok) {
        xlog("L_INFO", "Webhook notification sent successfully\n");
    } else {
        xlog("L_ERR", "Webhook notification failed: $http_err\n");
    }
}

# Outbound routing response handler
route[OUTBOUND_ROUTING] {
    if ($http_ok) {
        xlog("L_INFO", "Outbound routing configured via API\n");
    } else {
        xlog("L_ERR", "Outbound routing API failed: $http_err\n");
    }
}

# Reply route
onreply_route {
    if (status=~"[12][0-9][0-9]") {
        route(RTPENGINE);
    }
}

# Failure route
failure_route[MANAGE_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }
    
    # Try next destination if available
    if (t_check_status("408|503")) {
        if (t_next_contacts()) {
            t_relay();
            exit;
        }
    }
}

# Trunk failure route for outbound calls
failure_route[TRUNK_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }
    
    # Try next trunk in dispatcher group
    if (t_check_status("408|503|404|486|600")) {
        if (ds_next_dst()) {
            t_relay();
            exit;
        }
    }
    
    # No more trunks available
    xlog("L_ERR", "All trunks failed for call $ci\n");
}